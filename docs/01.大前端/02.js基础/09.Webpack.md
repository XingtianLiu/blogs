---
title: Webpack
date: 2020-11-12 22:05:12
permalink: /pages/6e6ae7/
categories:
  - 大前端
  - js基础
---
# Webpack

[toc]

模块化解决了开发过程中代码组织问题，但是随着模块化的引入，也出现了新的问题，比如：

- ESModule 存在环境兼容问题，尽管主流浏览器最新版本都已经支持了，但是开发人员没法统一所有用户浏览器版本；
- 模块过多，网络请求频繁。通过模块化划分出来的模块会比较多，而前端应用又是运行在浏览器环境中，每个应用用到的文件都需要从服务器请求，这些零散的模块文件就会导致浏览器频繁发出请求，影响工作效率；
- 所有资源都需要模块化，应用开发过程中不仅仅只有 JavaScript 代码，其它资源（HTML、css、图片等等）也需要模块化；

虽然模块化有很多问题，但是模块化是必要的，不过需要在原有的基础上，引入更好地方案或者工具解决这些问题，让开发人员可以在开发阶段享受模块化带来的优势，又不必担心模块化对生产环境产生的影响。这些工具需要满足：

- 编译代码，将开发阶段编写的包含新特性的代码，转换为能够兼容绝大多数环境的代码；
- 将散落的模块文件再次打包到一起，解决浏览器中频繁对模块发出请求的问题，文件的模块划分大多数情况下只需要开发阶段，因为它能够更好地帮我们组织代码，运行环境很多情况是没有必要的；
- 需要支持不同种类的资源，方便把样式、图片、字体等等都当做模块使用，这样整个前端应用就有了一个统一的模块化方案，有了方案之后就可以统一代码控制模块化，统一维护；

前面两个需求只需要借助于之前了解的构建系统，配合编译工具就可以实现，最后一个需求就很难通过这种方式解决，这就需要前端模块打包工具。前端领域目前有很多工具就很好地解决了以上几个问题，其中比较主流的就是 webpack、parcel、rollup。以 webpack 为例：

- 作为模块化打包工具，就很好地解决了 JavaScript 模块化打包问题，通过webpack就可以将零散的模块打包到同一个 JavaScript 文件中，有环境兼容问题的代码就可以在打包阶段，通过模块加载器（loader）编译转换；

- 其次 webpack 还具备模块拆分的能力，它能将应用当中所有的模块代码按照我们的需要打包，这样一来就不需要担心把所有的代码全部打包到一起产生的文件会比较大的问题，我们可以把应用加载过程中初次运行时必须的模块打包到一起，其它模块单独存放，实现增量加载；

- 支持JavaScript 中以模块化载入任意类型的资源文件，例如可以在 JavaScript 中可以直接 import 一个 css 文件，这些 css 文件最终会通过 style 标签的形式工作，其它类型文件也可以有类似的方式；

其它打包工具也是类似的，所有的打包工具都是以模块化为目标，这里说的模块化是对整个前端项目模块化，而不仅仅是 JavaScript 模块化，它可以让我们在开发阶段更好的享受模块化带来的优势，同时又不必担心模块化的影响。

## QuickStart

webpack 作为目前最主流的前端模块打包器，它提供了一整套前端项目模块化方案，而不仅仅局限于对 JavaScript 模块化，提供webpack 提供的前端模块化方案，可以很轻松地对前端项目开发过程中涉及到的所有资源进行模块化，因为 webpack 想法比较先进，而且随着版本迭代文档也不断更新，基本上覆盖了大多数现代化 web 应用开发过程。基本使用：

```javascript
  // src/element.js
  export default () => {
    const element = document.createElement('h2')
    element.textContent = "Hello"
    element.addEventListener('click', () => {
      console.log("Hello")
    })
    return element
  }
  // src/index.js
  import createElement from './element.js'
  const dom = createElement()
  document.body.append(dom)
  // index.html
  <html>
    <head>
      <title>webpack</title>
    </head>
    <body>
      <script src="./src/index.js" type="module"></script>
    </body>
  </html>
```

初始化：``npm init -y``；
安装 webpack 相关：``yarn add webpack webpack-cli --dev``；
打包：``yarn webpack``，自动从 src/index.js 打包；

## 配置文件

webpack4 以后的版本支持零配置的方式直接启动、打包，整个打包过程会按照约定将 src/index.js 作为打包的入口，最终打包的结果存放在 dist/main.js 中，但是很多时候需要自定义一些打包路径，此时就需要为 webpack 添加配置文件，具体的做法就是在项目的根路径下添加一个 webpack.config.js 文件，这个文件是一个运行在 node 中的 js 文件，需要按照 CommonJS 规范编写代码：

```javascript
  const path = require('path')
  module.exports = {
    entry: "./src/index.js", // 如果是相对路径，前面的 './' 不可省略
    output: {
      filename: "bundle.js", // 输出文件名
      path: path.join(__dirname, "output") // 需要绝对路径
    }
  }
```

webpack4 还新增了一个工作模式，这种用法大大简化了 webpack 配置的复杂程度，可以理解为针对不同环境的预设配置，通过 mode 设置，默认为 production，在这个模式下 webpack 会启动一些优化插件，例如：自动压缩代码，这对实际生产环境是友好的，但是打包结果没法阅读，可以通过 cli（或者配置文件）指定参数模式：

```shell
  # 默认 production（压缩代码）还有：
  #  development（优化打包速度、添加调试辅助）
  #  none 运行最原始状态的打包，不做任何处理

  # cli
  yarn webpack --mode=production
  # 配置
  module.exports = {
    mode: "production"
  }
```

## webpack 打包文件结构

**代码结构：**

将模式设置成 none，以最原始状态打包，执行打包（折叠代码：ctrl +k、Ctrl+0），得到：

  ![webpack打包结构-立即执行函数](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/webpack打包结构-立即执行函数.png)

- 整体是一个立即执行函数，它是 webpack 工作入口，调用时传入了一个数组，展开这个数组，数组中每个元素都是参数列表相同的函数，整理的函数就是源代码中对应的模块，也就是说我们的模块都会被包裹到这样的函数中，从而实现模块私有作用域；

  ![webpack打包结构-模块](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/webpack打包结构-模块.png)

- 展开工作入口函数，函数内部并不复杂，最开始定义了一个 installedModules 对象，用于缓存加载过的模块，紧接着定义了一个\__webpack_require\__函数，这个函数用于加载模块，再往后就是在\__webpack_require\__ 挂载了一些数据和工具函数，执行到最后调用了\__webpack_require\__函数，传入了 0（moduleId）加载模块，这里的模块 ID 就是传入模块数组的下标。

  ![webpack打包结构-函数内部](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/webpack打包结构-函数内部.png)

**运行过程：**

在浏览器打开页面，开启 debug 调试工具，流程如下：

- 1.最开始接收到的就是两个模块对应的函数；

  ![webpack-调试1](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/webpack-调试1.png)

- 2.中间不用管往下走，最后执行 \__webpack_require\__函数，\__webpack_require\__ 内部先判断模块有没有被加载过：
  - 如果加载过，就从缓存中读取模块的的 exports；
  - 如果没有，就创建新的 module 对象，然后执行模块对应的函数，把 module.exports, module, module.exports, \__webpack_require\__传入进去。这样就实现了通过 export 导出成员，通过\__webpack_require\__ 载入模块；

  ![webpack-调试2](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/webpack-调试2.png)

- 3.在模块内部首先调用了 \__webpack_require\__.r ，这个函数用于在导出对象上添加一个 \__esModule 标记，用于对外界标识这是一个 ES Module；

  ![webpack-调试3](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/webpack-调试3.png)

- 4.接着往后调用了 \__webpack_require\__(1)，加载第二个模块（也就是第一个模块的依赖），获取 "default"，接着再按照 2/3 两步加载依赖。第一个模块加载依赖后，执行主要流程；

  ![webpack-调试4](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/webpack-调试4.png)

这就是一个大致的运行过程，有了整个过程就会发现，webpack 打包后的代码并不会特别复杂，只是把所有模块放到了同一个文件中，另外提供了一些基础工具函数，保持模块依赖关系。

## 资源加载器

webpack 的加载器有点像生活中的生产车间，用于处理和加工打包过程中遇到的资源文件，loader 可以大致分为三类：

- 最常见的就是编译转换类型的 loader，这类加载器会把资源文件转换为 JavaScript 代码，比如：css-loader 把 css 转换成了 JavaScript 模块，实现提供 JavaScript 运行 css；

- 其次就是文件操作类型加载器，通常会把资源文件拷贝到输出目录，又将访问路径导出，例如：file-loader；

- 最后还有一种针对代码质量检查的加载器，用于对代码进行校验，用于统一代码风格，提高代码质量；

### css-loader

```jsx
  // main.css
  body{
      background-color: red;
      height: 400px;
      width: 400px;
  }
  // webpack.config.js
  const path = require('path')
  module.exports = {
    mode: "none",
    entry: "./src/main.css", // 可以正常工作，显示红色背景
    output: {
      filename: "bundle.js",
      path: path.join(__dirname, "output")
    },
    module:{
      rules:[{
        test: /.css$/,
        use:[
          'style-loader',
          'css-loader'
        ]
      }]
    }
  }
```

我们确实可以把 css 作为打包如果，不过 webpack 的打包入口一般还是 js 文件，因为打包入口算是应用的运行入口，目前而言前端的业务是由 JavaScript 驱动的，正确的做法还是把 js 作为打包的入口，然后在 js 代码中通过 import 的方式引入 css 文件，这样 css-loader 仍然可以正常工作。

```javascript
// webpack.config.js
const path = require('path')
module.exports = {
  mode: "none",
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.join(__dirname, "output")
  },
  module:{
    rules:[{
      test: /.css$/,
      use:[
        'style-loader',
        'css-loader'
      ]
    }]
  }
}

// index.js
import createElement from './element.js'
import './main.css'
const dom = createElement()
document.body.append(dom)
```

传统的做法中是将样式和行为分离开，单独维护、单独引入，webpack 基于在 js 中载入 css，其实 webpack 不仅仅建议在 js 中引入 css ，而是更进一步建议引入任何当前代码所需要的资源文件，这是因为真正需要这个资源的不是应用而是代码，这就是 webpack 的哲学，这样可以把资源文件和代码一起维护起来。JavaScript 代码主要用于完成业务功能，放大来看就是驱动了整个前端应用，而在实现应用过程中可能需要用到图片、样式等等资源，如果建立了这种关系，逻辑更加合理，另外还可以保证上线时资源文件不会缺失，每个文件都是必要的。

### file-loader

目前 webpack 社区提供了非常多的资源加载器，大多数资源加载器都类似 css-loader，都是将资源模块转换为 JavaScript 代码的方式工作，但是还有一些资源文件，例如图片、字体，这些文件是没有办法通过 JavaScript 的方式表示的，对于这类资源我们需要使用文件资源加载器，也就是 file-loader。

```javascript
// webpack.config.js
const path = require('path')
module.exports = {
  mode: "none",
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.join(__dirname, "output/dist"),
    publicPath: 'dist/' // 其中 /不能省略
  },
  module:{
    rules:[{
      test: /.jpg$/,
      use:[
        'file-loader'
      ]
    }]
  }
}

// index.js
import jpg from './test.jpg'
const img = new Image()
img.src = jpg
document.body.append(img)
```

打包过后会在 output 目录下多一个 .jpg 图片，不过文件的名称发生了改变（后续介绍），打开 bundle.js 找到最后一个 module，发现他就是把打包后的文件名称给导出去了，入口模块直接使用了导出的路径，并没有复杂的地方。

![file-loader](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/file-loader.png)

再查看 \__webpack_require\__.p 发现它就是设置的 publicPath，这也就说明了 / 不能省略的原因。

![file-loader](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/file-loader2.png)

webpack 在打包时遇到了图片文件，然后根据 webpack.config.js 中的匹配规则，匹配到文件加载器，文件加载器先是将导入的文件拷贝到输出目录，然后将拷贝路径作为当前模块的返回值返回，这样所需要的资源就被发布出来了，同时也可以通过模块的导出成员拿到访问路径。

### url-loader

除了像 file-loader 这种通过拷贝文件的形式处理文件外，还有一种通过 Data Urls 的形式表示文件，这种方式也非常常见。Data Urls 是一种特殊的协议，它可以用于直接表示一个文件，传统 url 一般采用 http 形式，需要服务器上有一个对应的文件，然后通过请求这个地址得到对应的文件。而 Data Urls 的 url 就可以表示文件内容，这种 url 的文本就包含了文件内容，使用这种 url 就不会发送任何 http 请求。

```shell
# 参考：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Data_URIs

# Data URLs 由四个部分组成：前缀(data:)、数据MIME类型、可选的base64标记、数据本身
data:[<mediatype>][;base64],<data>

# 例如：base64 的 Hello, World!
data:text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D
```

如果是图片、字体这些无法通过文本表示的二进制文件，可以对文件内容进行 base64 编码，以编码后的结果（也就是字符串，一般情况下会比较长，但是浏览器可以解析）的形式表示，在 webpack 打包时，同样可以使用这种方式实现，通过 Data Urls 就可以表示如何类型的文件了，具体做法就是需要使用到一个加载器 url-loader，

```javascript
const path = require('path')

module.exports = {
  mode: "none",
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.join(__dirname, "output/dist"),
    publicPath: 'dist/' // 其中 /不能省略
  },
  module: {
    rules: [{
      test: /.jpg$/,
      use: [
        {
          loader: 'url-loader',
          options: {
            limit: 10 * 1024 // 10k 以下的文件转换为 data url
          }
        }
      ]
    }]
  }
}
```

在此配置生效后，webpack 在打包时遇到了 jpg 文件，就会使用 url-loader 将文件编码，dist 目录下就不会有之前那样的 .jpg 文件了，而 bundle.js 中最后一个模块导出的就不再是文件路径，而是一个完整的 data url。

![url-loader1](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/url-loader1.png)

复制这个地址，在浏览器地址栏输入，图片可以正常显示。

![url-loader2](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/url-loader2.png)

这种方式非常适合应用当中体积比较小的资源，因为体积过大的话就会造成打包结果变大，影响性能，最佳的实践方式就是把项目中比较小的文件通过 url-loader 嵌入代码，减少应用发送请求的次数。对于较大的文件还是应该通过 file-loader 的方式，以单文件的方式存放，提高加载速度，url-loader 允许通过配置的方式（代码中的 options 选项）选择多大文件嵌入代码（如果配置 options ，一定要安装 file-loader，因为超出大小的文件会使用 file-loader）。

### babel-loader

由于 webpack 默认只能处理 import、export，但不会编译 es6 的代码，webpack 仅仅只对模块进行打包工作，所以才会对 export import 做一些转换，除此之外并不能转换其它的 es6 特性。

如果需要处理 es6 的其他语法，需要为 js 文件配上额外的编译型 loader，最常见的就是 babel-loader（需要依赖 @babel/core，另外还需要特性转换插件集合 @babel/preset-env）。

```javascript
const path = require('path')

module.exports = {
  mode: "none",
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.join(__dirname, "output/dist"),
    publicPath: 'dist/' // 其中 /不能省略
  },
  module: {
    rules: [{
      test: /.js$/,
      use: [
        {
          loader: 'babel-loader',
          // babel-loader 编译功能基于 @babel/core
          // 怎样编译依赖于 babel 的插件
          options: {
            // @babel/preset-env 包含所有 es6 新特性
            presets:['@babel/preset-env']
          }
        }
      ]
    }]
  }
}
```

webpack 默认只是打包工具，不会处理代码中的 es6 或者更高版本的新特性，如果需要处理，需要为 js 配置单独的加载器实现。

## loader

webpack 可以触发模块的加载其它几种方式：

- 遵循 ES Module 标准的 import 声明；

- 遵循 CommonJS 的 require 函数（如果载入 ES Module，需要获取 default 属性）；

- 遵循 AMD 标准的 define 函数和 require 函数；

- 一些独立的加载器也会处理加载资源时加载到的模块，例如：
  - css-loader 在加载 css 时加载到了 @import 或者 url 函数，也会触发资源加载；
  - html loader 在加载 HTML 时加载到了 src 属性，也会触发模块加载；

```jsx
const path = require('path')
module.exports = {
  mode: "none",
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.join(__dirname, "output/dist"),
    publicPath: 'dist/'
  },
  module: {
    rules: [{
      test: /.css$/,
      use: [
        'style-loader',
        'css-loader'
      ]
    }, {
      test: /.jpg$/,
      use: [
        'file-loader'
      ]
    }, {
      test: /.html$/,
      use:{
        loader: 'html-loader',
        options:{
          attributes:{
            list:[{
              attribute: 'src',
              tag: 'img',
              type: 'src',
            },
            {
              tag: 'a',
              attribute: 'href',
              type: 'src',
            }]
          }
        }
      }
    }]
  }
}
// css
body{
    height: 400px;
    width: 400px;
    background-image: url(./test.jpg);
    background-size: cover;
}
```

webpack 在打包时遇到了  css文件，会使用 css-loader 处理它，处理过程中发现 css 使用 url() 载入图片，就会把图片作为资源文件加入到打包过程，webpack 会根据资源文件找到对应的 loader，例子中交给 file-loader 处理。

![htmlcss](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/htmlcss.png)

在代码中所有需要引用到的资源，都会被 webpack 找出来，然后根据配置交给不同的 loader 处理，最后将处理结果打包到输出目录，webpack 通过这样的方式实现项目的模块化。

## webpack 工作原理

在 webpack 官网就很清楚地描述了 webpack 工作原理，在前端项目中一般都会散落着各种各样的代码以及资源文件，比如：js、html、css、jpg、png、scss、json。

- webpack 会根据配置找到一个文件作为入口（一般情况下为 js文件），webpack 会顺着入口文件的代码，根据代码中出现的 import、require 等语句，解析推断出来所依赖的资源模块，然后分别解析每个资源文件对应的依赖，最后就形成了整个项目依赖关系的依赖树；

- 有了这个依赖树后，webpack 会递归这个依赖树，然后找到每个节点对应的资源文件，最后根据配置文件中的 rules 属性找到模块所对应的加载器，然后交给对应的加载器加载这个模块；

- 最后会将加载到的结果放入打包结果中，从而实现整个项目的打包。

整个过程中 loader 起了很大的作用，如果没有 loader 就没法实现资源文件的加载，webpack 就只能用于 js 代码合并，

## loader 工作原理

loader 作为 webpack 的核心机制，内部工作原理也非常简单，我们通过开发一个 Markdown loader 深入了解 loader 工作原理。需求是开发一个 Markdown 文件加载器，希望开发完成之后可以在代码中直接导入 Markdown 文件。Markdown 文件一般是被转换为 HTML 文件之后呈现到页面，所以希望 import  得到的结果就是被转换的字符串。

```javascript
// 每个 webpack-loader 都需要导出一个函数，函数就是对资源的处理过程
// 函数的的输入就是加载到的资源内容，输出就是加工过后的结果
module.exports = source=>{
    console.log(source)
    return 'hello'
}
```

编译后使用 serve output + 浏览器打开报错，打开编译文件发现 loader 就是把加载到的结果拼接到了 modules 的字符串中，此时没法识别 hello ，所以报错：

![loader原理1](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/loader原理1.png)

修改为：

```javascript
module.exports = source=>{
    console.log(source)
    return `console.log('hello')`
}
```

![loader原理2](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/loader原理2.png)

webpack 的加载过程有点类似于工作管道，可以在管道中使用多个 loader，但是需要管道工作最后返回的代码必须是一段 JavaScript 代码（如果是其它内容，语法可能不通过）。所以开发的 loader 要么返回一段代码，要么在后面接另一个合适的加载器，接着处理返回结果。

返回JavaScript代码：

```javascript
const path = require('path')

module.exports = {
  mode: "none",
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.join(__dirname, "output/dist"),
    publicPath: 'dist/'
  },
  module: {
    rules: [{
      test:/.md$/,
      // use 可以使用模块路径
      use: './src/markdown-loader'
    }
  ]
  }
}


const marked = require('marked')
module.exports = source => {
    // 返回 JavaScript 代码，其中 JSON.stringify 转义换行符、内部引号
    return `export default ${JSON.stringify(marked(source))}`
}
```

交给下一个 loader：

```javascript
const path = require('path')

module.exports = {
  mode: "none",
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.join(__dirname, "output/dist"),
    publicPath: 'dist/'
  },
  module: {
    rules: [{
      test:/.md$/,
      // 先执行 markdown-loader，然后执行 html-loader
      use: ['html-loader','./src/markdown-loader']
    }
  ]
  }
}

const marked = require('marked')
module.exports = source => {
    // 返回 html 字符串，交给下一个 loader
    return marked(source)
}
```

通过以上实例可以知道 loader 就是一个从输入到输出的转换，loader 其实是一种管道的概念，可以将此次的处理结果交给下一个 loader，通过多个 loader 完成一个功能，例如 css-loader + style-loader，sass-loader 也需要配合其他 loader。

## 插件机制

插件机制是 webpack 的另一个核心概念，loader 用于实现各种各样文件资源的加载，从而实现整体项目的打包，plugin 用于解决除了资源加载以外，其它自动化方面的问题。比如：可以在打包前自动清除 dist 目录、拷贝不需要打包的静态资源文件到输出目录、压缩打包结果输出的代码，有了 plugin 机制就可以解决大多数前端工程化的工作。

### clean-webpack-plugin

webpack 每次打包的结果都是覆盖到 dist 目录，而 dist 中可能存在的之前的遗留文件，再次打包只能覆盖掉同名的文件，已经移除的资源文件就会一直积累在里面，非常不合理，合理的办法就是在每次打包前自动清理 dist 目录，这样的话 dist 中就只会存在我们需要的文件，clean-webpack-plugin 就很好的实现了这样的需求。

webpack.config.js 中通过 plugins 数组引入：

```javascript
const path = require('path')
const {CleanWebpackPlugin}= require('clean-webpack-plugin')
module.exports = {
  mode: "none",
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.join(__dirname, "output/dist"),
    publicPath: 'dist/'
  },
  // 用于配置插件
  plugins:[
    // plugin 一般导出的是类型，所以可以通过 new 创建
    new CleanWebpackPlugin()
  ]
}
```

有了以上配置就可以在打包前清理 dist 目录了。

### html-webpack-plugin

除了清理 dist 目录外，还有一个需求就是自动生成使用打包结果的 html，前面的例子 html 都是通过硬编码的方式直接存放在特定目录下的，这种情况有两个问题：

- 在项目发布时，需要同时发布 html 和 所有打包结果，这样相对麻烦，而且上线之后需要确保路径引用都是正确的；
- 如果输出的 bundle 文件名发生了变化，script 所引用的路径也就需求手动修改；

解决这两个问题的最好办法就是通过 webpack 自动生成 html 文件，也就是让 html 也参与到构建过程，构建过程中 webpack 知道生成了多少 bundle，webpack 将这些 bundle 添加到 html 中。这样的话 html 也就输出到了 dist 目录，发布时只要把 html 发布出去就好了，另外对于 bundle 的引用是注入进来的，不需要手动的硬编码，可以确保路径的引用是正确的，具体需要借助 html-webpack-plugin 实现。

```javascript
// 配置之后自动生成 index.html，其中引用了 bundle.js
const path = require('path')
const HtmlWebpackPlugin= require('html-webpack-plugin')
module.exports = {
  mode: "none",
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.join(__dirname, "dist")
  },
  plugins:[
    new HtmlWebpackPlugin()
  ]
}
```

默认生成的 html 有很多不足，比如标题需要修改，另外还需要自定义一些元数据标签、基础的 dom 结构。对于简单的定义可以通过修改 html-webpack-plugin 属性实现：

```javascript
const path = require('path')
const HtmlWebpackPlugin= require('html-webpack-plugin')
module.exports = {
  mode: "none",
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.join(__dirname, "dist")
  },
  plugins:[
    new HtmlWebpackPlugin({
      title:'标题',// HTML标题
      meta:{ // 设置 meta 标签，例如 viewport
        viewport: 'width=device-width'
      }
    })
  ]
}
```

如果需要大量的自定义，更好的做法是在源代码了中添加一个用于生成 HTML 文件的模板，然后让 html-webpack-plugin 根据模板生成页面，模板可以使用 ejs 语法编写，在模板中可以通过 htmlWebpackPlugin.options 访问 HtmlWebpackPlugin 配置数据（其中 htmlWebpackPlugin 是 HtmlWebpackPlugin 提供的变量，也可以添加自定义变量）。

```javascript
const path = require('path')
const HtmlWebpackPlugin= require('html-webpack-plugin')
module.exports = {
  mode: "none",
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.join(__dirname, "dist")
  },
  plugins:[
    new HtmlWebpackPlugin({
      title:'标题',
      template:'./src/index.template.html'
    })
  ]
}
// 获取 title 属性
<%= htmlWebpackPlugin.options.title %>
```

除了输出文件内容，还能同时输出多个页面文件，除非是单页面应用，否则的话一定需要输出多个页面，如果需要输出多个 html 也非常简单：

```javascript
const path = require('path')
const HtmlWebpackPlugin= require('html-webpack-plugin')
module.exports = {
  mode: "none",
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.join(__dirname, "dist")
  },
  plugins:[
    // 生成 index.html
    new HtmlWebpackPlugin({
      title:'标题',
      template:'./src/index.template.html'
    }),
    // 生成额外的 about.html 页面
    new HtmlWebpackPlugin({
      filename:'about.html', // 默认是 index.html
    })
  ]
}
```

打包过后就生成了 index.html 和 about.html 两个文件，如果需要创建多个页面只需要在插件列表中加入多个 html webpack plugin 实例对象，每个都用于生成一个 html。

### copy-webpack-plugin

在项目中一般还有一些不需要参与构建的静态文件，它们也需要发布到线上，例如位置的 favicon.ico，一般可以把它们放在根目录下的 public 目录中，我们希望webpack 在打包时可以把它们一并复制到输出目录，对于这种需求可以借助于 copy-webpack-plugin 实现：

```javascript
const path = require('path')
const CopyWebpackPlugin= require('copy-webpack-plugin')
module.exports = {
  mode: "none",
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.join(__dirname, "dist")
  },
  plugins:[
    new CopyWebpackPlugin([
      "public"
    ])
  ]
}
```

打包之后 public 目录下的所有文件都会被拷贝到输出目录。

### 插件原理

相比于 loader，plugin 可以触及到 webpack 的每一个环节，相比应用范围更宽，这样的插件机制是如何实现的呢？其实也非常简单，它的实现基于开发中最常见的钩子机制，它类似于事件。webpack 工作有很多环节，为了便于插件的扩展，webpack 几乎给每个环节都埋下了一个钩子，这样的话我们开发插件就可以往不同的节点上挂载不同的任务，就可以实现 webpack 能力的扩充。具体的钩子可以参考 [官方文档](https://webpack.js.org/api/compiler-hooks/)

webpack 要求插件必须是一个函数，或者是一个包含 apply 方法的对象，一般可以把插件定义为一个类型，然后在类型中定义一个 apply 方法，使用的时候通过这个类型构建一个实例。apply  方法会在 webpack 启动时自动被调用，它接收一个 compiler 参数，这个 compiler 就是 webpack 工作过程中最核心的对象，它包含了此处构建的所有信息，我们也是通过这个对象注册钩子函数。

我们的需求是希望插件可以用于清除 webpack 在打包生成的 js 中没有必要的注释，方便 bundle.js 阅读。有了这个任务我们需要明确执行时机（也就是哪个钩子上面），我们的需求是删除注释，也就是 bundle 文件内容明确之后才能调用，在 hooks 文档中的 emit 钩子会在 webpack 输出文件之前调用。

```javascript
const path = require('path')
class MyPlugin{
  apply(compiler){
    // 通过 compiler.hooks.emit 访问钩子
    // 然后通过 tap 方法注册任务
    // tap 方法接收两个参数：插件名称、需要挂载的函数
    // compilation 可以理解为打包过程中的上下文，所有打包结果都会放到这个对象中
    compiler.hooks.emit.tap('MyPlugin',compilation=>{
      // compilation.assets  资源文件信息，键就是文件名称
      for(const name in compilation.assets){
        // console.log(name,'---------') // 文件名称
        // console.log(compilation.assets[name].source())// 文件内容
        if(name.endsWith('.js')){
          const source = compilation.assets[name].source()
          // source 方法用于获取文件内容
          compilation.assets[name].source = ()=>source.replace(/\/\*\*\*\*\*\*\//g,'')
          // size 返回大小，是必须的方法
          compilation.assets[name].size = ()=>source.length
        }
      }
    })
  }
}
module.exports = {
  mode: "none",
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.join(__dirname, "dist")
  },
  plugins:[
    new MyPlugin()
  ]
}
```

通过这个插件我们明确了插件是往 webpack 生命周期钩子里面挂载函数实现的，更深层原理后面介绍。

## 实际开发环境

基于当前 webpack 的概念和用法应对日常的开发工作，还是远远不够的，那是因为编写源代码，然后通过 webpack 打包、运行应用、然后刷新浏览器这种周而复始的方式过于原始，实际开发中还按照这种开发方式必然大大降低开发效率。我们理想的开发环境：

- 希望能够以 HTTP Server 的方式运行，可以通过浏览器直接访问，而不是以文件的形式预览，这样一来更接近生产环境状态，二来可以支持 ajax 之类的 api；

- 希望修改源代码之后 webpack 就可以自动完成构建，然后浏览器可以及时显示最新的结果，这样就可以减少开发过程中额外的重复操作；

- 支持 sourceMap，这样一来的话运行过程中一旦出现错误，就可以根据错误的堆栈信息快速定位到源代码的位置，便于调试应用；

这些需求 webpack 都有相对于的功能实现了。

### 自动编译

目前我们采用的方式都是手动执行 webpack 打包命令得到打包结果，这种办法特别的麻烦，我们可以使用 webpack-cli 提供的 watch 工作模式解决这个问题，在这种模式下，项目下的文件会被监听，一旦文件发送变化就会自动运行打包任务。具体的用法也非常简单，就是在启动webpack 命令时，添加一个 --watch 参数，这样的话 webpack 就会以监视模式运行，在打包完成之后 cli 不会立即退出，会等待文件的变化，然后再次工作，一直到手动结束 cli，这种模式下就只要专注编码，不需要手动完成重复的工作。

### 实时刷新浏览器

在自动编译的问题解决之后，我们希望能够以 http server 运行，可以实时刷新浏览器。BrowserSync 实现了自动刷新的功能，如果使用 browser-sync 启动的 http 服务就可以完成实时刷新。通过这种方式有很多弊端，比如：

- 操作上太麻烦了，因为需要使用两个工具；
- 效率减低了，webpack 会不断的写入磁盘，browser-sync 不断地从磁盘读取，这样多出了很多磁盘操作；

## webpack dev server

### 使用

webpack dev server 是 webpack 官方推出的开发工具，它提供了一个开发服务器，并且将自动编译和自动刷新浏览器等一系列对开发友好的功能集成到了一起，我们可以使用这个工具解决之前的问题，因为这是一个高度集成的工具，所以使用起来也非常简单，webpack dev server 提供了一个 cli，可以直接在npm script 中写入 webpack-dev-server，运行这个命令就会自动使用 webpack 打包应用，并且启动一个 http server 运行打包结果，运行之后还好监听代码变化，一旦文件发生变化就会自动重新打包，这一点和 watch 模式是一样的。不过 webpack dev server 为了提高工作效率，并没有把打包结果写入到磁盘当中，它把打包结果暂时存储在内存中，而内部的 http server 就是从内存中把结果读出来，然后发送给浏览器，这样一来就减少了很多不必要的磁盘读写操作，从而大大提高构建效率，还可以传入 --open 的参数自动唤醒浏览器，打开运行地址。

webpack dev server 默认会将构建的结果文件作为开发服务器的资源文件，那也就是说只要是提高 webpack 打包能够输出的文件都可以被正常访问到，但是如果有一些静态资源也需要被开发服务器访问的话（实现 copy-webpack-plugin 功能），要额外的告诉 webpack dev server，具体方法就是在 webpack.config.js 中添加一个对应的配置：

```javascript
const path = require('path')
const HtmlWebpackPlugin= require('html-webpack-plugin')
module.exports = {
  mode: "none",
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.join(__dirname, "dist")
  },
  // 静态资源配置
  devServer:{
    contentbase: ['./public']
  },
  plugins:[
    new HtmlWebpackPlugin({
      title:'标题'
    })
  ]
}
```

copy-webpack-plugin 往往是 build 环境使用（上线前的最后一次打包），平时的开发环境一般不会使用，因为开发过程中会频繁重复执行打包任务，如果拷贝的文件比较多、大，每次都执行的话，打包速度会降低。

### 代理

由于是开发服务器的缘故，会将应用运行在 localhost 的一个端口上面，而上线之后应用又和 api 部署到同源地址下面，这样就会出现生产环境的跨域问题，如果服务端支持 CROS 也就不存在这个问题了，但是并不是每个服务端都支持 CROS。如果前后端同源部署，后端根本没用必要开启 CORS，所以这个问题会经常出现，解决的最好办法就是在开发服务器中配置代理服务，也就是把本地服务代理到开发服务器，webpack dev server 支持代理服务的配置，

```javascript
const path = require('path')
const HtmlWebpackPlugin= require('html-webpack-plugin')
module.exports = {
  mode: "none",
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.join(__dirname, "dist")
  },
  devServer:{
    contentBase: ['./public'],
    // 代理，每个属性就是代理规则的配置
    proxy:{
      '/api':{
        // 匹配到 /api 就转发到 https://api.github.com
        // 请求 localhost:port/api/users -> https://api.github.com/api/users
        target:'https://api.github.com',

        // 可以通过重写去掉 /api
        pathRewrite:{
          '^/api': '' // /api/user 开头的地址，重写为 /users
        },
        // 代理服务器默认使用浏览器地址栏的主机名，也就是 localhost:port
        // 一般情况下开发服务器需要根据主机名，判断当前请求属于哪个后端
        // 改为 true，就会向实际代理的主机名发起请求
        changeOrigin: true
      }
    }
  },
  plugins:[
    new HtmlWebpackPlugin({
      title:'标题'
    })
  ]
}
```

## source map

通过构建、编译操作可以将开发阶段的源代码，转换为能够在生产环境中运行的代码，这是一种进步，但是这种进步也就意味着实际生产环境的代码和实际运行的代码又很大的差异，这种情况下如果需要调试我们的应用，或者运行过程中出现了意料之外的错误就会造成无法定位的问题。这是因为无论是调试还是报错都是基于转换后的代码，source map （源代码地图）就是解决这类问题的最好办法，它记录了源代码和转换后代码的映射关系，转换后的代码通过 source map 文件就可以逆向得到源代码，目前很多第三方库都有一个 .map 的 source map 文件，格式化发现它由几个字段组成：

- version（source map 版本）；
- sources（转换前源文件名称，可能是多个文件映射存储成一个 map）；
- names（源代码中的成员名称，压缩代码时会把开发时编写的有意义变量名替换成简短的字符，用于压缩体积）；
- mappings（source map 的核心属性，是一个 base64 编码的字符串，记录转换后的字符与转换前对应的关系，有了这个文件可以通过在转换后的代码中，添加一行注释的方式引入这个source map 文件，比如：//# sourceMappingURL=jquery-3.4.1.min.map），如果添加了注释，浏览器会自动请求这个 sourcemap 文件，然后根据文件内容逆向解析出文件源代码，便于调试，同时因为有了映射的关系，源代码中如果出现了错误，也就能很容易定位到问题了；

source map 的作用就是前端引入构建、编译概念之后导致前端代码和运行的代码不一致产生的问题。

webpack 的打包过程同样支持为打包结果生成 source map 文件，它提供了很多不同的模式，

```javascript
const path = require('path')
const HtmlWebpackPlugin= require('html-webpack-plugin')
module.exports = {
  mode: "none",
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.join(__dirname, "dist")
  },
  // 用于配置开发过程中的辅助工具，webpack 支持 12种webpack 风格，每种效果和效率都不相同，效果最好生成速度最慢
  // 参考：https://shiguanghai.top/blogs/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%20SourceMap.html#%E4%B8%8D%E5%90%8C%E9%A2%84%E8%AE%BE%E7%9A%84%E7%A4%BA%E4%BE%8B%E7%BB%93%E6%9E%9C%E5%AF%B9%E6%AF%94
  // https://webpack.js.org/configuration/devtool/#root
  devtool: 'source-map',
  devServer:{
    contentBase: ['./public']
  },
  plugins:[
    new HtmlWebpackPlugin({
      title:'标题'
    })
  ]
}

```

![sourcemap](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/sourcemap.png)

webpack 的 devtool 除了 source-map 这种模式之外还支持很多其它模式，具体可以参考文档中不同模式之间的对比表，表中分别从初次打包速度、重新打包速度、是否适合在生产环境使用、所生成的 source map 质量四个维度对比了不同模式之间的差异。

![sourcemap2](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/sourcemap2.webp)

### 模式差异

```javascript
const HtmlWebpackPlugin = require('html-webpack-plugin')

const modules = [
  'eval',
  'cheap-eval-source-map',
  'cheap-module-eval-source-map',
  'eval-source-map',
  'cheap-source-map',
  'cheap-module-source-map',
  'inline-cheap-source-map',
  'inline-cheap-module-source-map',
  'source-map',
  'inline-source-map',
  'hidden-source-map',
  'nosources-source-map'
]
// webpack.config.js 支持导出数组的方式
module.exports = modules.map(item => {
  return {
    devtool: item,
    mode: 'none', // 不会做额外的处理
    entry: './src/index.js',
    output: {
      filename: `${item}/index.js`
    },
    module: {
      rules: [
        {
          test: /\.js$/,
          use: {
            loader: 'babel-loader',
            options: {
              presets: ['@babel/preset-env']
            }
          }
        }
      ]
    },
    plugins: [
      new HtmlWebpackPlugin({
        filename: `${item}.html`
      })
    ]
  }
})
```

打包之后 ``serve dist`` ，然后打开浏览器查看各个模式的差异

**eval模式：**

eval 是 JavaScript 中的一个函数，可以用于执行 JavaScript 代码，默认这段代码会运行在临时的虚拟机中，如果在 eval 执行的 JavaScript 中添加一段 ``//# sourceURL= test.js`` 的注释内容，此时这段代码运行的环境就是 ``test.js``，这意味着我们可以通过这种方式改变文件的所属环境的名称（还是在虚拟机中，只不过告诉了引擎这段代码所属路径，这只是一个标识）。

![eval1](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/eval1.png)

该模式在编译器中使用 EvalDevToolModulePlugin 作为 source map 的处理插件。打包之后点击查看运行的错误，看见的确实模块代码，因为在这种模式下会将每个模块转换的代码都放在 eval 函数中运行，并且在 eval 函数执行的字符串最后通过 sourceURL 的方式说明文件路径，这样的话浏览器在执行这段代码时就知道这段代码所对应的源代码是哪个文件了。从而实现错误定位文件，这种模式下不会生成 source map 文件，所以构建速度是最快的，效果也很简单，只能定位源代码名称，而不知道行列信息。

![eval2](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/eval2.png)

**eval-source-map：**

eval source map 同样使用 eval 函数执行模块代码，不过除了可以定位错误出现的文件，还能定位具体的行列信息，因为这种模式下，它生成了 source map 。

**cheap-eval-source-map：**

这种模式的名字可以推断出，它是在 eval-source-map 的基础之上加了一个 cheap，它打包了阉割版的 source map，这种模式下的 source map 只能定位到行，而没有列的信息，相比之下生成速度会快。

**cheap-module-eval-source-map：**

这种模式就是在 cheap-eval-source-map 的基础上多了一个 module，这种模式下定位的源代码和编写的代码是一致的，而前一种是转换后的结果。带有 module 的模式是没有加工的源代码，不带的是加工后的结果。

**inline-source-map：**

它和普通的 source-map 效果是一样的，只不过 source-map 模式下是以物理文件的形式存在，而 inline 使用 data urls 的方式将 source map 嵌入到代码中，这样会导致代码体积变大。

**hidden-source-map：**

这种模式下是看不到 source map 效果的，但是确实生成了 source map 文件，它生成了注释文件，但是却没有引入该文件，这种模式一般用于开发第三方包。

**nosources-source-map：**

这种模式下能够看见错误出现的行列信息，但是看不到源代码，这种模式需要结合源代码才能找到错误出现的位置，一般用于在生产环境中保护源代码不会被暴露。

**总结：**

通过以上分析可以发现：

- eval：是否使用 eval 执行模块代码；
- cheap：是否包含行信息；
- module：是否能够得到 loader 处理之前没被编译的源代码；
- inline：source map 存放在打包的代码中，js 代码体积会变大，一般不用；
- hidden：生成了，却没有引用，一般用于开发第三方包；
- nosources：有行列信息，但是没有 source map，一般用于生产环境；

例如：cheap-source-map 它没有 eval，也就意味着没有通过 eval 执行模块代码，没有 module 也就意味着返回的代码是 loader 处理之后的代码。

### 选择 source map 模式

虽然 webpack 支持各种各样的 source map 模式，但是一般只会应用到其中的几种，开发模式一般选择 cheap-module-eval-source-map，具体原因：

- 编写的代码风格要求每行不超过 80 个字符，只要定位到行就够了；
- 使用框架比较多，loader 转换后的代码和源代码差异大，最好能够调试源码；
- 虽然启动打包速度慢，但是大多数情况下使用 webpack dev server，重新打包速度快；

生产环境打包：

- none，因为 source map 会暴露源代码，容易被复原;
- nosources-source-map，不会暴露代码；

## 自动刷新问题

在此之前已经简单了解了 webpack dev server 的简单用法，它主要就是为开发人员提供了一个有好的开发服务器。使用 webpack dev server 可以让我们更加专注于编码，因为他可以监视到代码的变化，然后自动打包，最后通过自动刷新的方式同步到浏览器以便于及时预览，但是实际使用这些特性完成开发任务时，会出现很多问题，比如：前端页面输入框填写了内容，修改代码，页面自动刷新了，填写的内容丢失。如果页面整体刷新，页面之前保存的很多状态都会丢失，最好的办法在页面不刷新的情况下更新代码，针对这样的需求 webpack 同样可以满足。

### HRM

热插拔：可以在机器上插拔一些设备，但是机器的运行状态不受影响，而且插上的设备可以立即开始工作，例如 USB 设备。模块热替换（hot module replacement ）指的是可以在应用程序运行的过程中实时替换某个模块，应用的运行状态不会因此而改变，例如在运行过程中修改了某个模块，通过自动刷新就会导致应用整体刷新，页面中的状态信息就会丢失，如果使用热替换就可以实现将修改的模块实时替换到应用中，不必完全刷新应用。

HMR 集成在了 webpack dev server 中，通过配置 hot 和 HtmlWebpackPlugin 插件两步可以开启

```javascript
const path = require('path')
const webpack = require('webpack')
const HtmlWebpackPlugin = require('html-webpack-plugin')
module.exports = {
  mode: "none",
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.join(__dirname, "dist")
  },
  devtool: 'eval',
  devServer:{
    contentBase: ['./public'],
    hot:true
  },
  plugins:[
    new HtmlWebpackPlugin({
      title:'标题'
    }),
    new webpack.HotModuleReplacementPlugin()
  ]
}
```

以上配置只能在修改 css 的文件时可以达到热替换，因为 webpack 的 HMR 不像 webpack 其它功能一样开箱即用，它需要手动处理热替换逻辑。那为什么样式文件可以做到热替换？那是因为 style-loader 处理了热更新逻辑，css 的热更新相对比较简单，只需要把处理后的 css 及时替换到页面中，覆盖之前样式就可以实现样式文件更新。而 JavaScript 模块是没有任何规律的，模块可能导出对象、字符串、函数，对导出的数据使用也各不相同，所以 webpack 不知道如何处理更新后的模块，那也就没办法实现通用的处理所以模块热更新的方案，所以 js 更新后还是会刷新页面。在 vue-cli 或者 react 脚手架中，开发人员并没有处理 js 模块的更新逻辑也能达到热更新，那是因为使用的是框架开发，使用了框架，项目中的文件也就有了规律，有了规律就可以有通用的热替换办法，进而脚手架内部实现了相关的替换逻辑。

### HMR APIs

HMR 提供了一套用于热更新的 API，我们可以借助这套 API 处理某一个模块更新后如何替换到正在运行的页面中。

```javascript
// 这是打包的入口文件，也就是在这个模块中才加载其它模块，就是因为这个文件中使用了其它导入的模块
// 一旦模块更新之后，就需要重新使用这些模块，所以应该在这个文件处理其它模块的热替换
import createElement from './element.js'
import './main.css'
const element = document.createElement('div')
  element.textContent = "Hello"
  element.className = 'container'
  element.id = 'container'
  element.addEventListener('click', () => {
    console.log("Hello")
  })
const dom = createElement()
element.appendChild(dom)
document.body.append(element)
// hmr 为 module 提供了一个 hot 属性，它就是 hmr api 的核心对象
//      它提供了一个 accept 方法用于注册模块更新后的处理函数
//      accept 接收两个参数，第一个参数是模块路径，第二个是处理函数
// 手动处理后，更新 element 内容就不会覆盖页面的填写的表单了
if(module.hot){
    module.hot.accept('./element.js',()=>{
        console.log('element 更新了')
    })
}
```

一旦模块的更新被手动处理了，就不会触发自动刷新。

**js 热更新：**

例子中 element 模块导出的是一个函数，

```javascript
  export default () => {
    const element = document.createElement('input')
    console.log(1)
    return element
  }
```

当前模块的作用是创建一个 input 元素，所以热更新的步骤就是移除原有的元素，调用函数创建新的元素追加到页面中（可能需要添加之前的状态），这样就相当于这个模块重新工作了，通过这种方式可以按照自己的意愿更新模块。

```javascript
import createElement from './element.js'
import './main.css'
const element = document.createElement('div')
element.textContent = "Hello"
element.className = 'container'
element.id = 'container'
element.addEventListener('click', () => {
  console.log("Hello")
})

const dom = createElement()
element.appendChild(dom)
document.body.append(element)

if(module.hot){
    let input = dom // 记录元素
    module.hot.accept('./element.js',()=>{
        const value = input.value // 解决模块更新后 value 丢失问题
        element.removeChild(input)
        input = createElement()
        input.value = value
        input.id = 'id-input' // 加个id 测试
        element.appendChild(input)
    })
}
```

不同的模块有不同的逻辑，当前需要保留 input 的 value，如果是别的模块就不需要这么做，所以 webpack 没有办法提供通用的替换方案。

**图片热替换：**

相比于 js 的热替换，图片模块的热替换就会简单得多，只要将图片的 src 设置为新的图片路径就可以了。

```javascript
 // 可以通过画板修改保存查看
  module.hot.accept('./test.jpg',()=>{
      img.src = jpg
      img.id = 'id-image'
  })
```

对于一个长期开发的项目，可以自己设计一些替换规则，如果使用框架会有很多内置的替换规则，开发更简单。

**注意事项：**

- 1.处理热替换的代码如果有误，会导致页面刷新，这种情况可以把 webpack.config.js 的 ``hot:true`` 修改为：

```javascript
module.exports = {
  // ...balabala
  devServer:{
    // hot:true
    hotOnly: true // 如果热替换逻辑出错，会抛到浏览器
  }
  // ...balabala
}

```

- 2.如果使用了 HMR APIs，但是没有开启 HMR 插件，module.hot 不存在，``module.hot.accept`` 会报错，可以先判断这个对象是不是存在；

- 3.打包时，处理热替换的模块会被自动移除，不会影响生产环境；

## 生产环境优化

前面的内容都是为了提高开发体验，而这些配置结果也会变得越来越臃肿，这是因为在这个过程中 webpack 为了实现这些特性会自动往打包结果中添加一些额外的内容，例如 source map 和 hmr，他们都会往输出结果中添加额外的代码实现各自的功能，但是这些额外的代码对于生产环境来说是冗余的，因为生产环境和开发环境有很大的差异，生产环境强调的是以更少、更高效地代码去完成功能，更加注重运行效率，而开发环境中只注重开发效率，针对这个问题 webpack4 就推出了 mode 的用法，它提供了不同模式下的预设配置，其中生产模式就已经包括了很多生产环境需要的优化配置，同时 webpack 也建议为不同的工作环境创建不同的配置，以便于让打包结果适用于不同环境。

创建不同的环境配置方式主要有两种：

- 第一种是在配置文件中添加不同的判断条件，然后根据环境的判断条件不同导出不同的配置；
- 第二种就是为不同的环境单独添加一个配置文件，确保每个环境下都有一个对应的配置文件；

**判断条件：**

webpack 的配置支持导出一个函数，然后在函数中返回配置对象，这个函数可以接收了个参数，第一个是 env（也就是通过 cli 传递的环境名参数），第二个是 argv（也就是运行 cli 所传递的所有参数），可以借助这种方式为开发、生产环境返回不同的配置。

```javascript
const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const {CleanWebpackPlugin}= require('clean-webpack-plugin')

module.exports = (env, argv) => {
  const config =  {
    mode: "development",
    entry: "./src/index.js",
    output: {
      filename: "bundle.js",
      path: path.join(__dirname, "dist")
    },
    devtool: 'eval',
    plugins: [
      new HtmlWebpackPlugin({
        title: '标题'
      })
    ]
  }
  if(env === 'production'){
    config.mode = env
    config.devtool = false
    config.plugins.push(new CleanWebpackPlugin())
  }
  return config
}
```

**配置和环境对应：**

通过判断环境名参数，返回不同的配置对象只适用于中小型项目，一旦项目变得复杂配置文件也会变得复杂，对于大型项目还是基于使用不同环境对于不同配置文件的方式实现。在这种方式下，项目一般会有三个 webpack 配置文件其中两个（prod、dev）是用来适配不同的环境的，另一个是一个公共配置，因为开发环境和生产环境并不是所有配置都完全不同，这时需要一个公共文件抽象两者相同的配置。

社区提供了 webpack-merge 这个模块，用于合并 webpack 配置。

```javascript
// webpack.common.js
const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')
module.exports = {
    mode: "development",
    entry: "./src/index.js",
    output: {
        filename: "bundle.js",
        path: path.join(__dirname, "dist")
    },
    devtool: 'eval',
    plugins: [
        new HtmlWebpackPlugin({
            title: '标题'
        })
    ]
}
// webpack.prod.js
const { ModuleFilenameHelpers } = require('webpack')
const config = require('./webpack.common')
const { CleanWebpackPlugin } = require('clean-webpack-plugin')
const {merge} = require('webpack-merge')
// merge 会自动处理合并逻辑，plugins 不会覆盖 webpack.common.js 的内容
module.exports = merge(config, {
    mode: "production",
    devtool: false,
    plugins: [
        new CleanWebpackPlugin()
    ]
})
```

## 打包结果的优化

在 webpack4 中新增了的 production 模式下就开启了很多通用的优化功能，对应使用者而言这种开箱即用的体验是非常方便的，但是会忽略掉很多需要了解的东西，以至于出现问题之后无从下手。webpack 是怎样优化打包结果的？这里有几个需要了解的配置

**DefinePlugin：**

defineplugin 用于为代码注入全局成员，在 production 模式下这个插件默认就会启用，并且往代码中注入一股 process.env.NODE_ENV 的成员，很多第三方模块都是通过这个成员判断运行环境，从而决定是否执行向打印日志这些操作。

```javascript
const path = require('path')
const webpack = require('webpack')
module.exports = {
  mode: "none",
  entry: "./src/index.js", // 如果是相对路径，前面的 './' 不可省略
  // output 是对象
  output: {
    filename: "bundle.js", // 输出文件名
    path: path.join(__dirname, "dist") //path 必须是绝对路径
  },
  plugins: [
    // 每个键值都会被注入到代码中
    new webpack.DefinePlugin({
      // 值要求是一段符合 js 语法代码，如果是一段字符串，会被直接填写进去，不会加引号
      // 'appName': '阿里云盘'
      // appName: '"阿里云盘"'
      // 此处有一个小技巧，如果是一个值的话可以通过 JSON.stringify 转换
      appName: JSON.stringify('阿里云盘')
    })
  ]
}
```

这个插件可以用于注入一些变量，用于不同环境。

**tree sharking：**

tree sharking 字面意思就是摇树，一般伴随着摇树的动作树上的枯树枝、枯树叶就会掉落下来，在 webpack 中用于摇掉没有用的部分（未被引用的部分 dead-code），webpack 中就有这么一个功能，它可以自动检测出一些未引用的代码，然后移除掉。

```javascript
// element.js
export const span = createElement('span','span标签') // 冗余代码
export const h1 = createElement('h1','h1标签')
function createElement(tag,innerHTML){
  const element = document.createElement(tag)
  element.innerHTML = innerHTML
  return element
  console.log(1234) // 冗余代码
}

// index.js
import {h1} from './element'
console.log(h1)
// DefinePlugin 注入
console.log(appName) 
```

运行时设置 mode 为 production，就会发现冗余代码没有被输出，这个功能会在生产模式下自动开启。tree sharking 并不是 webpack 某一个功能选项，而是一组功能搭配使用之后的效果，在其它模式下需要手动开启：

```javascript
const path = require('path')
const webpack = require('webpack')
module.exports = {
  mode: "none",
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.join(__dirname, "dist")
  },
  // 集中配置优化功能
  optimization:{
    usedExports: true, // 只导出外部使用了的成员，但是代码还是会打包，只是不导出
    minimize: true, // 开启代码压缩
  }
}
```

usedExports 用于标记枯树枝、枯树叶，minimize 用于把不必要的内容摇下来。

![优化1](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/优化1.png)

![优化2](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/优化2.png)

**concatenateModules：**

除了 usedExports 和 minimize 之外还可以使用 concatenateModules 继续优化输出，普通的打包结果将每个模块放在单独的函数中，如果模块很多也就意味着在输出结果中会有很多的模块函数，开启 concatenateModules 属性之后 bundle.js 中就不再是一个模块对应一个函数了，而是把所有的模块都放到了同一个函数中，这个配置的作用就是尽可能将所有模块全部合并到一起，然后输出到一个函数中，这样既提升了运行效率又减少了代码体积，这个特性又被称为 scope hoisting （作用域提升），它是 webpack3 中添加的一个特性，

```javascript
const path = require('path')
const { CleanWebpackPlugin } = require('clean-webpack-plugin')
const webpack = require('webpack')


module.exports = {
  mode: "none",
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.join(__dirname, "dist")
  },
  // 集中配置优化功能
  optimization:{
    usedExports: true, // 只导出外部使用了的成员，但是代码还是会打包，只是不导出
    minimize: true, // 开启代码压缩
    concatenateModules: true // 开启模块合并
  }
}
```

![优化3](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/优化3.png)

**tree sharking 和 babel：**

由于 webpack 发展非常快，变化也就会比较多，所以当我们去找资料时，得到的结果并不适用于当前使用的版本，tree sharking 的资料更是如此，很多资料中都表示如果使用了 babel-loader，就会导致 tree sharking 失效，针对这个问题说明一下。首先 tree sharking 的实现必须依赖 ES Module 组织代码，也就是说交给 webpack 处理的代码必须是 ES Module 实现的模块化，webpack 在打包前会把模块交给不同的 loader 处理，最后讲处理后的结果打包到一起，为了转换 ES 新特性，很多时候都会使用 babel-loader 处理 js ，而在 babel转换代码时，就有可能处理掉代码中的 es module（@babel/preset-env就有这种功能），当转换逻辑工作的时候 ESModule 就会被转换，此时 webpack 拿到的代码就是以 commonjs 组织的代码，所以说 tree sharking 就会失效。

```javascript
const path = require('path')
module.exports = {
  mode: "none",
  entry: "./src/index.js", 
  output: {
    filename: "bundle.js",
    path: path.join(__dirname, "dist")
  },
  optimization: {
    usedExports: true
  },
  module: {
    rules: [{
      test: /.js$/,
      use: [
        {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env']
          }
        }
      ]
    }]
  }
}
```

此时结果：

![treesharking](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/treesharking.png)

这是因为在最新版本的 babel-loader 中，自动关闭了 ES module 转换的插件，在 babel-loader (injectCaller.js)中是支持 es module 的

![treesharking1](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/treesharking1.png)

在 preset-env 中利用这个选项禁用了转换：

![treesharking2](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/treesharking2.png)

所以说 babel-loader 最终得到的还是 ES module 代码，tree-sharking 也就可以正常工作了。修改配置：

```javascript
const path = require('path')
module.exports = {
  mode: "none",
  entry: "./src/index.js", 
  output: {
    filename: "bundle.js", 
    path: path.join(__dirname, "dist") 
  },
  optimization: {
    usedExports: true
  },
  module: {
    rules: [{
      test: /.js$/,
      use: [
        {
          loader: 'babel-loader',
          options: {
            presets: [
              // preset 名称，preset 属性
              // 以下配置保证打包环境不使用 es module
              // auto 表示根据环境自动判断，commonjs 表示强制转换为 commonjs
              ['@babel/preset-env',{modules:'commonjs'}]
            ]
          }
        }
      ]
    }]
  }
}
```

此时 tree sharking 就没法生效了。

最新版本的 babel-loader 并不会导致 tree sharking 失效，如果不确定最简单的办法就是在配置文件中使用 ``['@babel/preset-env',{modules:false}]`` 强制使用 es module，这样就保证了一定会启用 tree sharking。

![treesharking3](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/treesharking3.png)

**sideEffects：**

webpack 4  中还新增了一个 叫 sideEffects 的新特性，它允许通过配置的方式标识代码是否有副作用，为 tree sharking 提供更大的压缩空间。副作用是指模块除了导出成员是否还做了其它的事情，这个特性一般只在开发 npm 模块时才会用到。以一个例子说明，在例子中 div.js、index.js、span.js 都导出了一个函数，utils/index.js 统一导出，这种情况下，载入的是 utils/index.js，utils/index.js 下载入了所有的组件模块，这就会导致我们只想载入 div，但是所有的组件模块都会被加载执行，这种情况下打包结果 所有模块的导出都被打包到了 bundle.js，sideEffects 就可以用于解决此类问题。

```javascript
// div.js
export default () =>  document.createElement('div')
// h1.js
export default () =>  document.createElement('h1')
// span.js
export default () =>  document.createElement('span')
// utils/index.js
export {default as Span} from './span'
export {default as Div} from './div'
export {default as H1} from './h1'

// 入口文件
import {Div} from '../utils'
console.log(Div)


const path = require('path')
module.exports = {
  // ...balabala......
  optimization: {
    sideEffects: true
  },
  module: {
    rules: [{
      test: /.js$/,
      use: [
        {
          loader: 'babel-loader',
          options: {
            presets: [
              ['@babel/preset-env',{modules:false}]
            ]
          }
        }
      ]
    }]
  }
}
```

sideEffects 在 production 模式下也会自动开启，开启这个特性后 webpack 就会在打包前先检查代码所属的 package.json 有没有 sideEffects 这个标识，以此判断模块是不是有副作用，如果没有副作用，没有用到的模块就不会被打包。

![treesharking4](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/treesharking4.png)

使用 sideEffects 的前提是确保代码没有副作用，否则就会删掉有副作用的代码，例如：

```javascript
// 没有导出任何成员，只不过导入这个模块后，就可以使用为 number 提供的扩展
// 这个扩展就是副作用代码，此时如果还标识没有副作用的话，打包结果中扩展就丢失了
// 还有就是载入的 css 模块也是副作用代码，同样面临相同问题
Number.prototype.pad = function (size) {
  let result = this + ''
  while (result.length < size) {
    result = '0' + result
  }
  return result
}
```

![副作用1](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/副作用1.png)

解决办法就是在 package.json 中关闭副作用或者标识哪些文件有副作用，这样的话 webpack 就不会忽略这些模块了。比如：

```json
"sideEffects": true, 
// 改成
"sideEffects":["*.css","./src/extend.js"]
```

![副作用2](https://gitee.com/liuxingtian/markdow/raw/master/01.大前端/02.js基础/images/webpack/副作用2.png)

这些特性都是为了弥补 JavaScript 在早期设计遗留的一些问题。

## 打包方式

**代码分隔：**

webpack 实现前端项目的模块化优势很明显，但是同样存在一些弊端，那就是所有代码最终都会被打包到一起，如果应用复杂、模块非常多，打包结果就会特别的大，很多时候超过两三兆也是非常常见的事情，而事实情况是大多数情况下，在应用开始工作时并不所有模块都是必要的。但是这些模块又被全部打包到一起，需要任何一个模块都需要把整体加载进来，而应用运行在浏览器端，意味着会浪费掉很多流量和带宽，更为合理的做法就是把打包结果按照功能分包按需加载，这样就能大大提高响应速度和运行效率。

前面提到过 webpack 就是把散落的模块打包到一起，实现效率提升。项目中模块的粒度会非常细，很多情况下一个模块只是提供一个工具函数，不能形成一个完整的功能单元，如果不把模块组织到一起，运行一个小小的功能就需要加载非常多的模块，而主流的 http1.1 就有很多缺陷，例如并不能对同一个域名发起并行请求，而且每次请求都有延迟，另外除了传输内容外还有header信息，所以模块打包是必要的。但是物极必反模块不能太大，webpack 提供代码分包的功能，支持代码分隔。它提供把模块安装设计的规则打包到不同的 bundle 中，从而提高应用的响应速度，目前实现分包的方式主要有两种：

- 多入口打包：根据业务配置不同的打包入口；
- 动态导入：采用 es modeule 的动态导入功能实现模块的按需加载，此时 webpack 也会把动态导入的模块输出到单独的 bundle 中；

**多入口打包：**

多入口打包一般适用于传统的多页应用程序，最常见的划分规则就是一个页面对应一个打包入口，对于不同页面的公共部分再提取到公共结果中，这种方式使用起来也非常简单，

```javascript
const path = require('path')
const HtmlWebpackPlugin= require('html-webpack-plugin')

module.exports = {
  // entry 定义为对象
  entry: {
    'page1':'./page1/index.js',
    'page2':'./page2/index.js'
  },
  output: {
    // [name] 会被替换成入口的名称
    filename: "[name].bundle.js",
  },
  plugins: [
    //  HtmlWebpackPlugin 默认注入包含了所有打包结果的 html，可以通过 chunks 属性设置
    new HtmlWebpackPlugin({
      title: '页面1',
      template: './page1/index.html',
      filename: 'page1.html',
      chunks: ['page1']
    }),
    new HtmlWebpackPlugin({
      title: '页面2',
      template: './page2/index.html',
      filename: 'page2.html',
      chunks: ['page1']
    })
  ]
}
```

多入口打包非常容易理解，非常容易使用，但是也存在一个问题，就是不同的打包入口中一定会有一些公共模块，这种打包方式会导致在不同的打包结果中会有相同模块出现，如果公共模块体积比较大，影响会非常大，所以需要把这些模块提取出来。在 webpack 中提取公共模块的方式也很简单，只要在优化选项中开启一个 splitChunks 就可以了：

```javascript
const path = require('path')
const HtmlWebpackPlugin= require('html-webpack-plugin')

module.exports = {
  // ...balabal...
  optimization: {
    splitChunks: {
      minSize: 1, // 提取阈值
      chunks: 'all' // 所有的公共模块都提取到 bundle 中
    }
  }
}
```

**动态导入：**

按需加载是浏览器中非常常见的需求，一般按需加载是指加载数据，前端应用可以在运行过程中需要某个模块时才去加载这个模块，这种方式可以极大地节省带宽和流量，webpack 支持动态导入的方式支持按需加载，而且所有动态导入的模块都会被提取到单独的 bundle 中，相比多入口模式，动态导入更加灵活，因为可以通过代码逻辑控制需不需要导入某个模块或者什么什么加载。

```javascript
const render = () => {
    const hash = window.location.hash || '#page2'
    const mainElement = document.querySelector('#container')
    mainElement.innerHTML = ''
    if (hash === '#page2') {
        //  魔法注释命名为 page2，配合 webpack.config.js 可以得到名称
        import(/* webpackChunkName: 'page2' */'./page2.js').then(({ default: page1 }) => {
            mainElement.appendChild(page1())
        })
    } else {
        // 没有名称，打包结果是数字开头的 js 
        import('./page1.js').then(({ default: page2 }) => {
            mainElement.appendChild(page2())
        })
    }
}
render()
window.addEventListener('hashchange', render)
```

无需配置如何地方，只需要安装 es module 动态导入的方式导入即可， webpack 会自动处理分包、按需加载。

**魔法注释：**

默认过动态导入的 bundle 文件它的名字是数字，可以通过在 import 中加 ``/*webpackChunkName: '名称'*/`` 给 bundle 命名，相同的 chunkName 会被打包到一起。

## css 处理

```javascript
const path = require('path')
const MiniCssExtraPlugin = require('mini-css-extract-plugin')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const OptimizeCSSAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')
const TerserWebpackPlugin = require('terser-webpack-plugin')
module.exports = {
  mode: "none",
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.join(__dirname, "dist")
  },
  module: {
    rules: [{
      test: /.css$/,
      use: [
        MiniCssExtraPlugin.loader,
        'css-loader'
      ]
    }]
  },
  plugins: [
    // new OptimizeCSSAssetsWebpackPlugin(), // 任何情况下都会工作
    new HtmlWebpackPlugin(),
    new MiniCssExtraPlugin()
  ],
  optimization:{
    // 只在 production 时起作用
    minimizer:[ 
      // 给 minimizer 赋值会覆盖内置的压缩插件，需要手动加入 TerserWebpackPlugin
      new OptimizeCSSAssetsWebpackPlugin(),
      new TerserWebpackPlugin()
    ]
  }
}
```

**MiniCssExtractPlugin：**

这个插件可以把 css 代码从打包结果中提取出来，通过这个插件可以实现 css 模块的按需加载。

一般情况下 css 先交给 css-loader 处理，然后交给 style-loader（style 的形式注入），使用 mini-css-extract-plugin 后不需要再使用 style-loader，如果 css 文件比较小就没有必要提取 css。

**OptimizeCssAssetsWebpackPlugin：**

压缩提取的 css 。如果配置在 plugins 中在代码任何修改都会生效，可以配置在 minimizer 数组中只在 production 时生效。

## 输出 hash

一般部署前端资源文件时，都会启用静态资源缓存，这样的话用户的浏览器就会缓存应用的静态资源，后续就不再需要请求服务器，这样的话应用响应速度就会提升，不过开启服务器缓存也有一些问题，如果缓存失效时间设置过短效果就不是特别明显，如果设置时间过长应用发生更新又没有及时更新到客户端，为了解决这个问题，在生产模式下需要给文件名添加 hash 值，这样的话一旦资源发生改变，文件名称也可以跟着变化，对于客户端而言，全新的文件名就是全新的请求，那也就没有缓存的问题了，这样我们可以把服务器缓存更新的时间设置得非常长，而不用担心缓存问题。webpack 支持为导出的文件设置一个 hash，不过它支持三种 hash，效果各不相同：

```javascript
const path = require('path')
const MiniCssExtraPlugin = require('mini-css-extract-plugin')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const OptimizeCSSAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')
const TerserWebpackPlugin = require('terser-webpack-plugin')

module.exports = {
  // .....balabala....
  output: {
    // filename: "bundle[hash].js",// 项目级别的 hash ，只有项目任何地方发生改变打包的 hash 都会发生变化
    // filename: "bundle[chunkhash].js", // chunkhash，同入口 hash 都是相同的，入口会发生被动改变
    // filename: "bundle[contenthash].js", // 文件级别的 hash ，文件内容相同 hash 不变
    filename: "bundle[contenthash:8].js", // 通过 :number 指定 hash 长度
    path: path.join(__dirname, "dist")
  }
}
```
