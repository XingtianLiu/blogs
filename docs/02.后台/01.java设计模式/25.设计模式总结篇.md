---
title: 设计模式总结篇
date: 2019-12-02 10:11:00
permalink: /pages/64eaa6/
categories:
  - 后台
  - java设计模式
---
# 设计模式总结篇

[toc]

## 1. 回顾

23种设计模式可以分为创建型、行为型、结构型三类，其中：

- 创建型用于创建对象，它屏蔽了对象的创建细节，把客户端创建对象的职责分离出去；

- 结构型解决怎样组装现有的类；

- 行为型涉及到算法和对象间职责的分配，行为模式描述了对象和类之间怎样通信；

创建型模式：

模式名称|描述|备注
-|-|-|
简单工厂|定义一个类，根据输入信息返回不同对象|工厂类职责过重
工厂方法|把工厂接口化来构建若干个子类|可能导致类数量暴增
抽象工厂|创建一系列相关对象或相互依赖对象的|新增产品可能要改抽象
建造者|生产、装备一个复杂对象|产品差异太大，抽象复杂
原型|实现Cloneable接口，用原型实例指定类|深拷贝麻烦
单例|创建一个对象，到处使用|有7种创建方式，**推荐枚举**

这六个模式不是特别复杂，建造者和抽象工厂可能容易混淆，第二节中有差异比较。

结构型模式：

模式名称|描述|备注
-|-|-|
适配器|将一类的接口转换成客户希望的另外一个接口|
享元|有很多对象多次使用，使用对象池共享|
装饰器|动态地给一个对象增加一些额外的职责|排错难
桥接|抽离维度，针对维度扩展|需要实现的功能存在多个维度
组合|将对象组合成树形结构以表示部分整体的关系|树形结构中使用频繁
外观|为子系统中的一组接口提供一致的界面|客户端不能直接访问子组件
代理|A类够不着B类，通过能够访问的C类调用B|

这七个模式中前五个很容易识别出来，第二节有针对后两种的差异比较。

行为型模式：

模式名称|描述
-|-|-|
模板方法|定义一个流程，通过继承子类都有类似流程|
策略|封装一系列实现，使得它们可以相互替换|
责任链|使多个对象都有机会处理请求，从而避免请求的送发者和接收者之间的耦合关系
状态|允许一个对象在其内部状态发生改变时改变其行为
中介者| 用中介对象来封装对象交互，各对象不需要显式地相互引用
观察者|一对多关系，当一个对象发生改变时，需要把这种改变通知给其他对象|
迭代器|一对多关系，不暴露内部对象，提供一种访问方式|
解释器|定义一种语言的文法|
备忘录|获取并保存一个对象的内部状态，以便以后恢复它
访问者|可以在不改变各元素类的前提下定义作用于这个元素的新操作
命令|将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化

## 2. 差异比较

引用知乎网友的一句话：

> GOF总结出来的23种设计模式不全部是在一个抽象层面上去总结的

23种设计模式本来就不一定在一个频道上，终究是为了满足基本原则而从实践中来，有的是抽象了不同的部分(状态模式抽象了状态流程，适配器模式是抽象了接口转换部分)，有的减少了类个数爆炸(装饰器模式)。 全方位各角度比较设计模式实际上意义不大，我就简单地比较常见的几种类似模式在特定情况下的差异：

参见：<https://www.zhihu.com/question/2109282>

### 2.1. 抽象工厂、建造者

在创建型模式中抽象工厂和创建者模式都能生成多个对象，但是二者有着本质区别。

**建造者模式**返回一个组装好的复杂产品，**抽象工厂模式**返回一系列相关的产品；

**抽象工厂模式**中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，**建造者模式**中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，它侧重于一步步构造一个复杂对象；

**建造者模式**里，有个指导者，由指导者来管理建造者，用户是与指导者联系的，指导者联系建造者最后得到产品。即建造模式可以强制实行一种分步骤进行的构造过程。**工厂模式**是将对象的全部创建  过程封装在工厂类中，由工厂类想客户端提供最终的产品。而在**建造者模式**中，建造者类一般只提供产  品类中各个组件的建造，而将具体建造过程交付给指导者，由指导者负责将各个组件按照特定的规则组  建为产品，然后将组建好的产品交付给客户端。

### 2.2. 外观、代理

**代理模式中** 对象代表一个单一对象，而**外观模式中**对象代表一个子系统；

**代理模式中**对象无法直接访问对象，由代理提供单独的目标对象的访问，而通常**外观模式中**提供对子系统各元件功能的简化的共同层次的调用接口；

### 2.3. 外观、中介者

**中介者** 所做的是在模块之间进行通信，是多向的，但 **外观模式** 只是为某一个模块或系统定义简单的接口而不添加额外的功能，其它模块和外观模式没有直接联系，可以认为它是单向性。

### 2.3. 中介者、观察者

**中介者模式** 通过一个第三方对象来封装一系列对象的交互来减少对象间的互相引用，由此可见这需要一个第三方类实体对象，至于怎么封装其他对象(即如何持有对象)是不关注的；

**观察者模式** 对象间的一对多关系，观察者类监听某一个对象的事件，通过回调(或者其他方式)自动触发监听处理，具体怎么处理，有多少个对象参与是关注的。

**观察者** 是分发性的，注册的人都能收到，而且 **中介者** 则是单一的，使用者发个请求，中介者回一个，使用者不需要知道到底是谁回的，中介隐藏了对象之间的交互

考虑观察者一种惯用法，消息总结用来封装负责所有消息的订阅/发布，这样解偶了消息订阅者和事件生产者，这客观上新增了一个第三方对象，正好又变成了中介者模式解决问题的手段了。 在这个点上两者产生了交际，更重要的一点是，通过引入第三方对象(各种总线，消息总线，消息队列)来解决业务问题已经变得越来越普遍，两者界限已经模糊了。

本段参考知乎：<https://www.zhihu.com/question/21092827/answer/403817431>

扩展阅读：[JDK源码中，都有哪些NB的设计模式？](https://mp.weixin.qq.com/s/4_BF2RROlIRrZm_sNzpSWQ)
